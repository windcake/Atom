



###LinkedList简介
LinkedList是List接口的一种实现，底层数据结构基于双向链表。除了List接口，它还实现了Queue和Deque接口。
因为以上特点，在代码的注释中出现了如下叮咛。

```
的This class is primarily useful if you need queue-like behavior. It may also be useful as a list if you expect your lists to contain zero or one element, but still require the
  ability to scale to slightly larger numbers of elements. In general, though, you should
  probably use ArrayList if you don't need the queue-like behavior.

  如果你需要queue-like操作，或者你的list大部分情况下都只有0或1个元素，但是也有变大的需求，那么它可以用。
  否则建议使用ArrayList。

```

###数据结构

```
private static final class Link<ET> {
       ET data;

       Link<ET> previous, next;

       Link(ET o, Link<ET> p, Link<ET> n) {
           data = o;
           previous = p;
           next = n;
       }
   }
```




LinkedList是List接口的一种实现，数据结构基于双向链表。
支持包括null在内的所有元素。
有必要先解释一下双向链表，前一个对象
voidLink的previous就是lastLink
voidLink的next就是firstLink
其数据的组织是围绕voidLink展开的
也就是说LinkedList只持有voidLink，通过它去遍历整个list

唯一发现有个用处，好象是在JDK里设计缓存策略时有用。





```
public class LinkedList<E> extends AbstractSequentialList<E> implements
        List<E>, Deque<E>, Queue<E>, Cloneable, Serializable {

    private static final long serialVersionUID = 876323262645176354L;

    transient int size = 0;

    transient Link<E> voidLink;
//  双向链表的数据结构的节点类
// 其属性有三个 数据，上一节点，下一节点。
    private static final class Link<ET> {
      // 数据
        ET data;
//      前后节点，是Link类型的引用，用以引用前后两个Link类型的数据。
//      真正的对象放在堆里，这两个引用放在栈里。
//      也就是说，这是一个属性。
        Link<ET> previous, next;
        // 构造方法
        // 疑问：一个Link类里，为什么能有Link属性？
        Link(ET o, Link<ET> p, Link<ET> n) {
            data = o;
            previous = p;
            next = n;
        }
    }

// 构造函数，构造一个只含有voidLink的List
    public LinkedList() {
           voidLink = new Link<E>(null, null, null);
           voidLink.previous = voidLink;
           voidLink.next = voidLink;
       }

    public LinkedList(Collection<? extends E> collection) {
        this();
        addAll(collection);
    }

// 默认插入在链表尾部
    @Override
    public boolean add(E object) {
        return addLastImpl(object);
    }

    private boolean addLastImpl(E object) {
        Link<E> oldLast = voidLink.previous;
        // 分两步实现双向链表的插入
        // 第一步：将object的p属性设置为oldLast，n属性设置为voidLink
        // 第二部：将voidLink的p属性设和oldLast的n属性设置为newLink
        Link<E> newLink = new Link<E>(object, oldLast, voidLink);
        voidLink.previous = newLink;
        oldLast.next = newLink;
        size++;
        modCount++;
        return true;
    }

// 指定位置插入
    @Override
    public void add(int location, E object) {
        if (location >= 0 && location <= size) {
            Link<E> link = voidLink;
            // 先进行查找
            if (location < (size / 2)) {
                for (int i = 0; i <= location; i++) {
                    link = link.next;
                }
            } else {
                for (int i = size; i > location; i--) {
                    link = link.previous;
                }
            }
            // 然后进行插入
            Link<E> previous = link.previous;
            Link<E> newLink = new Link<E>(object, previous, link);
            previous.next = newLink;
            link.previous = newLink;
            size++;
            modCount++;
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    //  在某个指定位置插入某个集合
    // 有一个遍历集合的操作
    @Override
    public boolean addAll(int location, Collection<? extends E> collection) {
        if (location < 0 || location > size) {
            throw new IndexOutOfBoundsException();
        }
        int adding = collection.size();
        if (adding == 0) {
            return false;
        }
        Collection<? extends E> elements = (collection == this) ?
                new ArrayList<E>(collection) : collection;

        Link<E> previous = voidLink;
        // 前后哪边近，从哪边遍历。提高性能。
        if (location < (size / 2)) {
            for (int i = 0; i < location; i++) {
                previous = previous.next;
            }
        } else {
            for (int i = size; i >= location; i--) {
                previous = previous.previous;
            }
        }
        Link<E> next = previous.next;
        for (E e : elements) {
          // 分两步插入到previous的后边，这样循环下来，所有的elements都挨个插入到previous后边
          // 第一步：e的p属性设置成previous
          // 第二部：previous的next属性设置为newLink
            Link<E> newLink = new Link<E>(e, previous, null);
            previous.next = newLink;
            previous = newLink;
        }
        // 然后把之前previous后边的部分链接上，就完成了添加。
        previous.next = next;
        next.previous = previous;
        size += adding;
        modCount++;
        return true;
    }

    //  直接插入在队尾部，比指定位置插入少一步寻找位置的操作。
    @Override
    public boolean addAll(Collection<? extends E> collection) {
        int adding = collection.size();
        if (adding == 0) {
            return false;
        }
        Collection<? extends E> elements = (collection == this) ?
                new ArrayList<E>(collection) : collection;

        Link<E> previous = voidLink.previous;
        for (E e : elements) {
            Link<E> newLink = new Link<E>(e, previous, null);
            previous.next = newLink;
            previous = newLink;
        }
        previous.next = voidLink;
        voidLink.previous = previous;
        size += adding;
        modCount++;
        return true;
    }

    /**
     * Adds the specified object at the beginning of this {@code LinkedList}.
     *
     * @param object
     *            the object to add.
     */
    public void addFirst(E object) {
        addFirstImpl(object);
    }

    private boolean addFirstImpl(E object) {
      // 因为是双向循环链表，所以voidLink的next就是插入前的first
        Link<E> oldFirst = voidLink.next;
        // 插入操作同样是分两步
        Link<E> newLink = new Link<E>(object, voidLink, oldFirst);
        voidLink.next = newLink;
        oldFirst.previous = newLink;
        size++;
        modCount++;
        return true;
    }

  // 疑问：是怎样清除的？
  // 由于LinkedList对象只持有voidLink
  // 把voidLink的p和n都指向自己以后，其余的链表就不可达了，但他们仍是一个整体。
  // 能被回收，但是其中一个数据也被引用呢?岂不是会造成都不能被回收？
    @Override
    public void clear() {
        if (size > 0) {
            size = 0;
            voidLink.next = voidLink;
            voidLink.previous = voidLink;
            modCount++;
        }
    }



    @Override
    public boolean contains(Object object) {
        Link<E> link = voidLink.next;
        if (object != null) {
            while (link != voidLink) {
                if (object.equals(link.data)) {
                    return true;
                }
                link = link.next;
            }
        } else {
            while (link != voidLink) {
                if (link.data == null) {
                    return true;
                }
                link = link.next;
            }
        }
        return false;
    }
// 一个一个往下寻找
    @Override
    public E get(int location) {
        if (location >= 0 && location < size) {
            Link<E> link = voidLink;
            if (location < (size / 2)) {
                for (int i = 0; i <= location; i++) {
                    link = link.next;
                }
            } else {
                for (int i = size; i > location; i--) {
                    link = link.previous;
                }
            }
            return link.data;
        }
        throw new IndexOutOfBoundsException();
    }


    @Override
    public int indexOf(Object object) {
        int pos = 0;
        Link<E> link = voidLink.next;
        if (object != null) {
            while (link != voidLink) {
                if (object.equals(link.data)) {
                    return pos;
                }
                link = link.next;
                pos++;
            }
        } else {
            while (link != voidLink) {
                if (link.data == null) {
                    return pos;
                }
                link = link.next;
                pos++;
            }
        }
        // 记住如果没有索引到，就返回-1
        return -1;
    }

    //  先索引，索引到之后再删除。
    @Override
    public E remove(int location) {
        if (location >= 0 && location < size) {
            Link<E> link = voidLink;
            if (location < (size / 2)) {
                for (int i = 0; i <= location; i++) {
                    link = link.next;
                }
            } else {
                for (int i = size; i > location; i--) {
                    link = link.previous;
                }
            }
            Link<E> previous = link.previous;
            Link<E> next = link.next;
            previous.next = next;
            next.previous = previous;
            size--;
            modCount++;
            return link.data;
        }
        throw new IndexOutOfBoundsException();
    }

    @Override
    public boolean remove(Object object) {
        return removeFirstOccurrenceImpl(object);
    }


    @Override
    public E set(int location, E object) {
        if (location >= 0 && location < size) {
            Link<E> link = voidLink;
            if (location < (size / 2)) {
                for (int i = 0; i <= location; i++) {
                    link = link.next;
                }
            } else {
                for (int i = size; i > location; i--) {
                    link = link.previous;
                }
            }
            E result = link.data;
            link.data = object;
            return result;
        }
        throw new IndexOutOfBoundsException();
    }


    @Override
    public Object[] toArray() {
        int index = 0;
        Object[] contents = new Object[size];
        Link<E> link = voidLink.next;
        while (link != voidLink) {
            contents[index++] = link.data;
            link = link.next;
        }
        return contents;
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] contents) {
        int index = 0;
        if (size > contents.length) {
            Class<?> ct = contents.getClass().getComponentType();
            contents = (T[]) Array.newInstance(ct, size);
        }
        Link<E> link = voidLink.next;
        while (link != voidLink) {
            contents[index++] = (T) link.data;
            link = link.next;
        }
        if (index < contents.length) {
            contents[index] = null;
        }
        return contents;
    }
}
```
