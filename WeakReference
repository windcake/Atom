


继承自Reference，所以先了解一下它。
他是一个抽象类，除了系统提供的子类，不能创建别的子类。
也不建议这么做，因为引用和GC是息息相关的。

应该明确所谓强引用，和其他三种引用的联系和区别。

系统提供了三种引用类型，他们依次减弱：
SoftReference
WeakReference
PhantomReference（幽灵）

这个“弱”指的是，当GC来的时候，它更容易被回收。

为了正确的使用者三种引用，理解他们的clear和enqueue机制非常重要。

强引用：从根节点，至少有一个路径可达。并且没有其他三种引用。
软引用：强引用不可达。被软引用引用，并且没有弱和虚。

这个里边有个queue
volatile ReferenceQueue<? super T> queue
还有个enqueue方法，内部调用queue.enqueue(this);
enqueue()

满足如下几点的时候，GC就认为它是若引用。

强可及

弱引用是如何被JAVA虚拟机识别出来的

只存在WeakHashMap里的键值对，来一次GC之后，只被这个弱引用引用的就收走了。
但是key和value还在WeakHashMap里占着位置。
需要调用poll方法把它找出来，然后remove掉。

JAVA只有一种引用方式，就是引用妈。
所谓软弱虚，是从GC的策略来说的。

软引用和弱引用在添加到 ReferenceQueue 的时候，
其指向真实内存的引用已经被置为空了，相关的内存也已经被释放掉了。

虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。
当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。
ReferenceQueue queue = new ReferenceQueue();
SoftReference ref = new SoftReference(aMyObject, queue);
这样的话，是把ref这个SoftReference的强引用

queue的作用是GC通知程序哪个对象已经不可达了。

应该从Android的GC算法谈起


应该做个试验，
如果queue只是放的Reference。那么GC之后，内存应该就已经减小了。
那么就只起到了防止内存泄漏的作用，而没有起到缓存的作用。


当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,
但这个SoftReference对象已经不再具有存在的价值，
需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。
GC来了之后，软引用引用的对象被清除了，但这个软引用并没有被清除。
所以需要一个机制来清除这个软引用，这也就是ReferenceQueue的用处所在。

什么样的强引用可以被回收？
有向图，可达。
如果一个强引用只引用一个对象，那么它就不可达了，不可达之后就可以被GC。
对象落单之后，就会被回收。
所以之前才说 硬可达 软可达 弱可达


当一个对象
GC是如何判定系统内存不足? 是否有参数可以配置这个threshold?


SoftReference as late as possible
是到了不得不清理的时候才清理，
也就是内存实在不够用了，马上就要OOM了，采取清理。

WeakReference as soon as
只要它只是若引用，它就会被清理。

referenceQueue在WeakHashMap的构造函数里初始化。

referenceQueue里存的到底是什么？

Entry继承自WeakReference

这个weak到底weak的是谁？是key

put方法会将Entry和Queue联系起来

一个对象 Car car = new Car(),通过这样的方式被创建出来之后，应该一直被car引用的呀。
怎么着就算不适用了呢，而且被判定为软引用。
WeakHashMap的key是弱引用的，但是它的value是强引用。

一旦WeakReference返回null，说明这个弱引用引用的对象被回收了，那么这个弱引用也就没什么用了。
此时就有必要进行一些清理工作。
比如WeakHashMap,key被回收之后（key被回收的原理），其对应的Entry也应该被回收。
于是执行了poll方法回收Entry。
ReferenceQueue这个类使跟踪一个被回收的引用变的很简单。在弱引用的构造方法中传入一个queue之后，
当这个弱引用指向的对象被回收之后，这个弱引用会自动被加入Queue。然后就可以遍历这个QUeue进行清理工作。

JVM在GC的时候帮我们把WeakHashMap中的key的内存释放掉了，
那么 WeakHashMap中Entry数据怎么释放，看看 WeakHashMap的 ReferenceQueue怎么起的作用？


Entry的数据结构

```
private static final class Entry<K, V> extends WeakReference<K> implements
            Map.Entry<K, V> {
        final int hash;
        boolean isNull;
        V value;
        Entry<K, V> next;
        interface Type<R, K, V> {
            R get(Map.Entry<K, V> entry);
        }
        Entry(K key, V object, ReferenceQueue<K> queue) {
          // 这个key被包装成了，
            super(key, queue);
            isNull = key == null;
            hash = isNull ? 0 : Collections.secondaryHash(key);
            value = object;
        }

        public K getKey() {
            return super.get();
        }

        public V getValue() {
            return value;
        }

        public V setValue(V object) {
            V result = value;
            value = object;
            return result;
        }
    }

```


```
public V put(K key, V value) {
       poll();
       int index = 0;
       Entry<K, V> entry;
       if (key != null) {
        // 在数组里索引出 entry
           index = (Collections.secondaryHash(key) & 0x7FFFFFFF) % elementData.length;
           entry = elementData[index];
          // 如果冲突，在链表里依次往下拿，一直到最后一个。
           while (entry != null && !key.equals(entry.get())) {
            //  为空跳出，也就是队尾。
            // key相同跳出，需要覆盖。
               entry = entry.next;
           }
       } else {
        //  key == null entry在第一个
           entry = elementData[0];
           while (entry != null && !entry.isNull) {
             //  为空跳出，也就是队尾。
             // key相同跳出，需要覆盖。
               entry = entry.next;
           }
       }

      //  下边的逻辑也分两个，一个是空，也就是队尾。
       if (entry == null) {
           modCount++;
           if (++elementCount > threshold) {
               rehash();
               index = key == null ? 0 : (Collections.secondaryHash(key) & 0x7FFFFFFF)
                       % elementData.length;
           }
           entry = new Entry<K, V>(key, value, referenceQueue);
          //  插入到链表头部
           entry.next = elementData[index];
           elementData[index] = entry;
           return null;
       }
      //  另一个是key相同，然后替换value。
       V result = entry.value;
       entry.value = value;
       return result;
   }

```
// 这个方法运行后，就清除了。
// 每次执行 put remove等方法 都会先执行这个方法。清除不用的key
// poll一遍，不为空的都删除。删除的是Entry。
// poll里是数据是什么时候添加进去的？ 这里边添加的是什么呢?目前来看是Entery
// 在构造方法里添加的明明是 key 但这里取出来的却强转成了 Entry
// poll的源码在ReferenceQueue里，每poll一次，返回并删除这个引用。
//
```
void poll() {
       Entry<K, V> toRemove;
       while ((toRemove = (Entry<K, V>) referenceQueue.poll()) != null) {
           removeEntry(toRemove);
       }
   }
```

removeEntry方法
```
void removeEntry(Entry<K, V> toRemove) {
       Entry<K, V> entry, last = null;
       int index = (toRemove.hash & 0x7FFFFFFF) % elementData.length;
       entry = elementData[index];
       // Ignore queued entries which cannot be found, the user could
       // have removed them before they were queued, i.e. using clear()
       while (entry != null) {
           if (toRemove == entry) {
               modCount++;
               if (last == null) {
                   elementData[index] = entry.next;
               } else {
                   last.next = entry.next;
               }
               elementCount--;
               break;
           }
           last = entry;
           entry = entry.next;
       }
   }

```
JAVA的expungeStaleEntries方法
private void expungeStaleEntries() {
    Entry<K,V> e;
        while ( (e = (Entry<K,V>) queue.poll()) != null) {
            int h = e.hash;
            int i = indexFor(h, table.length);

            Entry<K,V> prev = table[i];
            Entry<K,V> p = prev;
            while (p != null) {
                Entry<K,V> next = p.next;
                if (p == e) {
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    e.next = null;  // Help GC
                    e.value = null; //  "   "
                    size--;
                    break;
                }
                prev = p;
                p = next;
            }
        }
    }
