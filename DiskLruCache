


LinkedHashMap<String, Entry> lruEntries;

## Journal文件是什么
LruCache的文件是在内存里的，所以它的泛型是key和value, 比如常见的<String,Bitmap>
但是磁盘缓存的文件是存在磁盘里，不能直接引用。那怎么去磁盘里找这个文件呢。
所以我们必须有一个地方去记录磁盘里都有哪些文件以及文件名。
journal文件就是干这个用的
于是问题就可以被这样解决，先把这些文件名加载到内存里，然后就可以去索引了。
当执行get方法的时候，提供一个文件名（key），如果找到了，再用流读到内存里使用。



## open方法
构造方法人用 private修饰的，所以提供的open方法。

open方法调用了readJournal方法
readJournal方法内部又调用了

```
private void readJournalLine(String line) throws IOException {
   int firstSpace = line.indexOf(' ');
   if (firstSpace == -1) {
     throw new IOException("unexpected journal line: " + line);
   }

   int keyBegin = firstSpace + 1;
   int secondSpace = line.indexOf(' ', keyBegin);
   final String key;
   if (secondSpace == -1) {
     key = line.substring(keyBegin);
     if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
       lruEntries.remove(key);
       return;
     }
   } else {

//  读key,也就是文件名
     key = line.substring(keyBegin, secondSpace);
   }

//  把文件名读进内存
   Entry entry = lruEntries.get(key);
   if (entry == null) {
     entry = new Entry(key);
     lruEntries.put(key, entry);
   }

   if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
     String[] parts = line.substring(secondSpace + 1).split(" ");
     entry.readable = true;
     entry.currentEditor = null;
     entry.setLengths(parts);
   } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
     entry.currentEditor = new Editor(entry);
   } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
     // This work was already done by calling lruEntries.get().
   } else {
     throw new IOException("unexpected journal line: " + line);
   }
 }

```
这个方法会把日志文件里的文件索引都读进HashMap
这样open方法就结束了。

## 
