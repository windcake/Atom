



## measure方法
在measure方法经过一通折腾，然后调用了onMeasure方法。
正如其方法注释中说，实际的测量工作是在onMeasure里的，因此，只有onMeasure方法可以被
子类继承，且必须被继承。

```
/**
  * The actual measurement work of a view is performed in
  * {@link #onMeasure(int, int)}, called by this method. Therefore, only
  * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
  * </p>
  */
public final void measure(int widthMeasureSpec, int heightMeasureSpec)
{
    onMeasure(widthMeasureSpec, heightMeasureSpec);
}
```

## MeasureSpec插播
其源码和注释如下
int 4字节 bit数是4*8 左移一位是*2 左移三十位够用

```
/**

   * 一个MeasureSpec封装了父布局或者子布局的需求。每个MeasureSpec提供了一个宽或者高的值
   * 它由size和mode组成。mode有三种
   * UNSPECIFIED
   * 父布局没有给子布局任何约束，它想多大多大。
   * EXACTLY
   * 父布局给子布局指定了一个确定的大小，子布局必须是这个大小，就不能为所欲为了。
   * AT_MOST
   * 子布局可以任意变大，直到某个指定的大小。
   * MeasureSpecs被实现为整形，减小了对象的占用。这个类把size和mode打包成int值。
   * MeasureSpecs are implemented as ints to reduce object allocation. This class
   * is provided to pack and unpack the &lt;size, mode&gt; tuple into the int.
   */
  public static class MeasureSpec {
      private static final int MODE_SHIFT = 30;
      // 1100000000000000000000
      private static final int MODE_MASK  = 0x3 << MODE_SHIFT;

      /** @hide */
      @IntDef({UNSPECIFIED, EXACTLY, AT_MOST})
      @Retention(RetentionPolicy.SOURCE)
      public @interface MeasureSpecMode {}

      /**
       * Measure specification mode: The parent has not imposed any constraint
       * on the child. It can be whatever size it wants.
       */
      public static final int UNSPECIFIED = 0 << MODE_SHIFT;

      /**
       * Measure specification mode: The parent has determined an exact size
       * for the child. The child is going to be given those bounds regardless
       * of how big it wants to be.
       */
      public static final int EXACTLY     = 1 << MODE_SHIFT;

      /**
       * Measure specification mode: The child can be as large as it wants up
       * to the specified size.
       */
      public static final int AT_MOST     = 2 << MODE_SHIFT;

      /**
       * Creates a measure specification based on the supplied size and mode.
       *
       * The mode must always be one of the following:
       * <ul>
       *  <li>{@link android.view.View.MeasureSpec#UNSPECIFIED}</li>
       *  <li>{@link android.view.View.MeasureSpec#EXACTLY}</li>
       *  <li>{@link android.view.View.MeasureSpec#AT_MOST}</li>
       * </ul>
       *
       * <p><strong>Note:</strong> On API level 17 and lower, makeMeasureSpec's
       * implementation was such that the order of arguments did not matter
       * and overflow in either value could impact the resulting MeasureSpec.
       * {@link android.widget.RelativeLayout} was affected by this bug.
       * Apps targeting API levels greater than 17 will get the fixed, more strict
       * behavior.</p>
       *
       * @param size the size of the measure specification
       * @param mode the mode of the measure specification
       * @return the measure specification based on size and mode
       */
       //~MODE_MASK是 0011111111111 和size按位与，得到前两位是0的数
       //MODE_MASK是  1100000000000和mode按位与恰好留下最高两位
       //然后再或 高两位和低三十位合并 得到完整的
      public static int makeMeasureSpec(@IntRange(from = 0, to = (1 << MeasureSpec.MODE_SHIFT) - 1) int size,
                                        @MeasureSpecMode int mode) {
          if (sUseBrokenMakeMeasureSpec) {
              return size + mode;
          } else {
              return (size & ~MODE_MASK) | (mode & MODE_MASK);
          }
      }

      /**
       * Like {@link #makeMeasureSpec(int, int)}, but any spec with a mode of UNSPECIFIED
       * will automatically get a size of 0. Older apps expect this.
       *
       * @hide internal use only for compatibility with system widgets and older apps
       */
      public static int makeSafeMeasureSpec(int size, int mode) {
          if (sUseZeroUnspecifiedMeasureSpec && mode == UNSPECIFIED) {
              return 0;
          }
          return makeMeasureSpec(size, mode);
      }

      /**
       * Extracts the mode from the supplied measure specification.
       *
       * @param measureSpec the measure specification to extract the mode from
       * @return {@link android.view.View.MeasureSpec#UNSPECIFIED},
       *         {@link android.view.View.MeasureSpec#AT_MOST} or
       *         {@link android.view.View.MeasureSpec#EXACTLY}
       */
      @MeasureSpecMode
      public static int getMode(int measureSpec) {
          //noinspection ResourceType
          return (measureSpec & MODE_MASK);
      }

      /**
       * Extracts the size from the supplied measure specification.
       *
       * @param measureSpec the measure specification to extract the size from
       * @return the size in pixels defined in the supplied measure specification
       */
      public static int getSize(int measureSpec) {
          return (measureSpec & ~MODE_MASK);
      }

      static int adjust(int measureSpec, int delta) {
          final int mode = getMode(measureSpec);
          int size = getSize(measureSpec);
          if (mode == UNSPECIFIED) {
              // No need to adjust size for UNSPECIFIED mode.
              return makeMeasureSpec(size, UNSPECIFIED);
          }
          size += delta;
          if (size < 0) {
              Log.e(VIEW_LOG_TAG, "MeasureSpec.adjust: new size would be negative! (" + size +
                      ") spec: " + toString(measureSpec) + " delta: " + delta);
              size = 0;
          }
          return makeMeasureSpec(size, mode);
      }
  }

```

## onMeasure方法
```

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
   }
```
其内部调用了setMeasuredDimension，并传了两个参数。这个参数是由getDefaultSize获得的，先看这个方法

```
public static int getDefaultSize(int size, int measureSpec里的) {
     int result = size;
     int specMode = MeasureSpec.getMode(measureSpec);
     int specSize = MeasureSpec.getSize(measureSpec);

     switch (specMode) {
     case MeasureSpec.UNSPECIFIED:
         result = size;
         break;
     case MeasureSpec.AT_MOST:
     case MeasureSpec.EXACTLY:
         result = specSize;
         break;
     }
     return result;
 }
```
如果mode是UNSPECIFIED即未指定，就返回传过来的size值
如果是AT_MOST或者EXACTLY就返回measureSpec里的specSize部分。
size值是getSuggestedMinimumWidth()的返回值
measureSpec是调用meaure的类传来的。

## 看一下getSuggestedMinimumWidth是怎么回事

```
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
```
这些都是系统默认值

## onMeasure实际是调用了setMeasuredDimension方法

```

protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }

    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;

        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }
```


在这个方法里把测量的宽高赋值给measuredWidth和measuredHeight就算完毕了。


## ViewGroup的测量

```
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
    }
```
先是调用测量孩子们，然后循环调用measureChild方法。
```
protected void measureChild(View child, int parentWidthMeasureSpec,
           int parentHeightMeasureSpec) {
       final LayoutParams lp = child.getLayoutParams();

       final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
               mPaddingLeft + mPaddingRight, lp.width);
       final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
               mPaddingTop + mPaddingBottom, lp.height);

       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
   }

```
注意注意，每个child都是一个view,调用view的measure方法，就回到一开始View测量的逻辑了。

## LinearLayout的onMearure方法

```

void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {
        mTotalLength = 0;
        int maxWidth = 0;
        int childState = 0;
        int alternativeMaxWidth = 0;
        int weightedMaxWidth = 0;
        boolean allFillParent = true;
        float totalWeight = 0;
        //竖直方向一共有多少个
        final int count = getVirtualChildCount();
        //拿到mode
        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);

        boolean matchWidth = false;
        boolean skippedMeasure = false;

        final int baselineChildIndex = mBaselineAlignedChildIndex;
        final boolean useLargestChild = mUseLargestChild;

        int largestChildHeight = Integer.MIN_VALUE;
        int consumedExcessSpace = 0;

        // See how tall everyone is. Also remember max width.
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
        // measureNullChild直接返回0
                mTotalLength += measureNullChild(i);
                continue;
            }

            if (child.getVisibility() == View.GONE) {
        // 奇怪，这个方法也返回0
               i += getChildrenSkipCount(child, i);
               continue;
            }
        // 如果有分隔线 就把分隔线加上
            if (hasDividerBeforeChildAt(i)) {
                mTotalLength += mDividerHeight;
            }

            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
          //加上本次循环child的宽度
            totalWeight += lp.weight;

            final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
            if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
                // Optimization: don't bother measuring children who are only
                // laid out using excess space. These views will get measured
                // later if we have space to distribute.
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
                skippedMeasure = true;
            } else {
                if (useExcessSpace) {
                    // The heightMode is either UNSPECIFIED or AT_MOST, and
                    // this child is only laid out using excess space. Measure
                    // using WRAP_CONTENT so that we can find out the view's
                    // optimal height. We'll restore the original height of 0
                    // after measurement.
                    lp.height = LayoutParams.WRAP_CONTENT;
                }

                // Determine how big this child would like to be. If this or
                // previous children have given a weight, then we allow it to
                // use all available space (and we will shrink things later
                // if needed).
                final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
                measureChildBeforeLayout(child, i, widthMeasureSpec, 0,
                        heightMeasureSpec, usedHeight);

                final int childHeight = child.getMeasuredHeight();
                if (useExcessSpace) {
                    // Restore the original height and record how much space
                    // we've allocated to excess-only children so that we can
                    // match the behavior of EXACTLY measurement.
                    lp.height = 0;
                    consumedExcessSpace += childHeight;
                }

                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                       lp.bottomMargin + getNextLocationOffset(child));

                if (useLargestChild) {
                    largestChildHeight = Math.max(childHeight, largestChildHeight);
                }
            }

            /**
             * If applicable, compute the additional offset to the child's baseline
             * we'll need later when asked {@link #getBaseline}.
             */
            if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
               mBaselineChildTop = mTotalLength;
            }

            // if we are trying to use a child index for our baseline, the above
            // book keeping only works if there are no children above it with
            // weight.  fail fast to aid the developer.
            if (i < baselineChildIndex && lp.weight > 0) {
                throw new RuntimeException("A child of LinearLayout with index "
                        + "less than mBaselineAlignedChildIndex has weight > 0, which "
                        + "won't work.  Either remove the weight, or don't set "
                        + "mBaselineAlignedChildIndex.");
            }

            boolean matchWidthLocally = false;
            if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
                // The width of the linear layout will scale, and at least one
                // child said it wanted to match our width. Set a flag
                // indicating that we need to remeasure at least that view when
                // we know our width.
                matchWidth = true;
                matchWidthLocally = true;
            }

            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            childState = combineMeasuredStates(childState, child.getMeasuredState());

            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            if (lp.weight > 0) {
                /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
                weightedMaxWidth = Math.max(weightedMaxWidth,
                        matchWidthLocally ? margin : measuredWidth);
            } else {
                alternativeMaxWidth = Math.max(alternativeMaxWidth,
                        matchWidthLocally ? margin : measuredWidth);
            }

            i += getChildrenSkipCount(child, i);
        }

        if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
            mTotalLength += mDividerHeight;
        }

        if (useLargestChild &&
                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
            mTotalLength = 0;

            for (int i = 0; i < count; ++i) {
                final View child = getVirtualChildAt(i);
                if (child == null) {
                    mTotalLength += measureNullChild(i);
                    continue;
                }

                if (child.getVisibility() == GONE) {
                    i += getChildrenSkipCount(child, i);
                    continue;
                }

                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                        child.getLayoutParams();
                // Account for negative margins
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            }
        }

        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;

        int heightSize = mTotalLength;

        // Check against our minimum height
        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

        // Reconcile our calculated size with the heightMeasureSpec
        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
        heightSize = heightSizeAndState & MEASURED_SIZE_MASK;

        // Either expand children with weight to take up available space or
        // shrink them if they extend beyond our current bounds. If we skipped
        // measurement on any children, we need to measure them now.
        int remainingExcess = heightSize - mTotalLength
                + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
        if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
            float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;

            mTotalLength = 0;

            for (int i = 0; i < count; ++i) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }

                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                final float childWeight = lp.weight;
                if (childWeight > 0) {
                    final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                    remainingExcess -= share;
                    remainingWeightSum -= childWeight;

                    final int childHeight;
                    if (lp.height == 0 && (!mAllowInconsistentMeasurement
                            || heightMode == MeasureSpec.EXACTLY)) {
                        // This child needs to be laid out from scratch using
                        // only its share of excess space.
                        childHeight = share;
                    } else {
                        // This child had some intrinsic height to which we
                        // need to add its share of excess space.
                        childHeight = child.getMeasuredHeight() + share;
                    }

                    final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                            Math.max(0, childHeight), MeasureSpec.EXACTLY);
                    final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,
                            lp.width);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);

                    // Child may now not fit in vertical dimension.
                    childState = combineMeasuredStates(childState, child.getMeasuredState()
                            & (MEASURED_STATE_MASK>>MEASURED_HEIGHT_STATE_SHIFT));
                }

                final int margin =  lp.leftMargin + lp.rightMargin;
                final int measuredWidth = child.getMeasuredWidth() + margin;
                maxWidth = Math.max(maxWidth, measuredWidth);

                boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &&
                        lp.width == LayoutParams.MATCH_PARENT;

                alternativeMaxWidth = Math.max(alternativeMaxWidth,
                        matchWidthLocally ? margin : measuredWidth);

                allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;

                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            }

            // Add in our padding
            mTotalLength += mPaddingTop + mPaddingBottom;
            // TODO: Should we recompute the heightSpec based on the new total length?
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth,
                                           weightedMaxWidth);


            // We have no limit, so make all weighted views as tall as the largest child.
            // Children will have already been measured once.
            if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
                for (int i = 0; i < count; i++) {
                    final View child = getVirtualChildAt(i);
                    if (child == null || child.getVisibility() == View.GONE) {
                        continue;
                    }

                    final LinearLayout.LayoutParams lp =
                            (LinearLayout.LayoutParams) child.getLayoutParams();

                    float childExtra = lp.weight;
                    if (childExtra > 0) {
                        child.measure(
                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                        MeasureSpec.EXACTLY),
                                MeasureSpec.makeMeasureSpec(largestChildHeight,
                                        MeasureSpec.EXACTLY));
                    }
                }
            }
        }

        if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
            maxWidth = alternativeMaxWidth;
        }

        maxWidth += mPaddingLeft + mPaddingRight;

        // Check against our minimum width
        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());

        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
                heightSizeAndState);

        if (matchWidth) {
            forceUniformWidth(count, heightMeasureSpec);
        }
    }
```
